# make a simple hello world 
.cpp file

#for small small cpp files, we simply do 
g++ -o //file.cpp temp

# and then run the 
./temp #obj file generated by the compiler

# but in large C++ projects, it is a nighmare to keep track of what is where, what is what version etc also, project needs to be cross-platform

# so we use something called cmake

# make a file: 
CMakeLists.txt  # write the name exactly this, it will be parsed by cmake ... to do what? we will see...

# write the syntax of cmake : see my tutorial project file

# cmake "builds" targets... so here the add_executable has the target main and the cpp file being used is hi.cpp 

# next make a "build" directory in the same dir where the project files are, it has all the "manifests" cmake makes

#to invoke cmake, 
:cmake .. #in the build directory

# the idea is that you are passing the path to wherever the CMakeLists.txt file exists and it returns the generated outputs in to current (build) directory

# cmake finds the c++ compiler on our system, finds related libs if needed and then generates files for us

# running the above gives // Build files have been written to: -------/build

#Cmake is a "Build Generator" it makes BUILD FILES for us... what does that mean?
# there is something called "make"; it uses makefiles to finally build oue executable from whateber rag tag bits and pieces of libraries and our own code we gave to cmake

:make  #type and run in the build directory

#it builds our target "main" which will be found in the /build directory and is a binary executable

./ _target_ # to run it and it does whatever you coded it to do



